
正则表达式介绍

正则表达式提供了功能强大、灵活而又高效的方法来处理文本。 
使用正则表达式的全面模式匹配表示法，可以快速分析大量文本，以找到特定的字符模式；
验证文本以确保它匹配预定义模式（如电子邮件地址）；
提取、编辑、替换或删除文本子字符串；
将提取的字符串添加到集合以生成报告。 
对于处理字符串或分析大文本块的许多应用程序而言，正则表达式是不可缺少的工具。

常规的用法可以参照 ./doc/.Net regular expression quick reference.png
这里也简单列举一下
\a	                 报警 (bell) 符 \u0007 
\b	                 退格键 \u0008 
\t	                 制表符 \u0009 
\r	                 回车符 \u000D （\r 与换行符 \n不是等效的。）
\v	                 垂直制表符 \u000B
\f	                 换页符 \u000C
\n	                 换行符 \u000A
\e	                 转义符 \u001B

\w	                 单词字符
\W	                 非单词字符
\s	                 空白字符
\S	                 非空白字符
\d	                 十进制数字
\D	                 不是十进制数的任意字符

[ character_group ]	 character_group中的任何单个字符。 默认情况下，匹配区分大小写
[^ character_group ] 求反：与不在 character_group 中的任意单个字符匹配。 默认情况下， character_group 中的字符区分大小写
[ first - last ]	 字符范围：与从 first 到 last的范围中的任意单个字符匹配。
.	                 通配符：与除 \n 之外的任意单个字符匹配。若要匹配文本句点字符（. 或 \u002E），你必须在该字符前面加上转义符 (\.)

难点：

反向引用构造
\ 数值	后向引用。 匹配编号子表达式的值。	(\w)\1	"seek" 中的 "ee"
\k< name >	命名后向引用。 匹配命名表达式的值。	(?<char>\w)\k<char>	"seek" 中的 "ee"  


正则表达式中的分组构造  https://docs.microsoft.com/en-us/dotnet/standard/base-types/grouping-constructs-in-regular-expressions

1、匹配的子表达式
以下分组构造捕获匹配的子表达式：
( 子表达式 )
其中 子表达式 为任何有效正则表达式模式。 使用括号的捕获按正则表达式中左括号的顺序从一开始从左到右自动编号。 捕获元素编号为零的捕获是由整个正则表达式模式匹配的文本。


默认情况下， (子表达式) 语言元素捕获匹配的子表达式。 但是，如果正则表达式模式匹配方法的 RegexOptions 参数包含 RegexOptions.ExplicitCapture 标志，或者如果 n 选项应用于此子表达式（参见本主题后面的 组选项 ），则不会捕获匹配的子表达式。
可以四种方法访问捕获的组：
通过使用正则表达式中的反向引用构造。 使用语法 \数字在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获的表达式的初始数字。
通过使用正则表达式中的命名的反向引用构造。 使用语法 \k<name>在同一正则表达式中引用匹配的子表达式，其中 name 是捕获组的名称，或使用 \k<数字>在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获组的初始数字。 捕获组具有与其原始编号相同的默认名称。 
通过使用 $数字 $ Regex.Replace number Match.Result 替换序列，其中 数字 是捕获的表达式的初始数字。
以编程的方式，通过使用 GroupCollection 对象的方式，该对象由 Match.Groups 属性返回。 集合中位置零上的成员表示正则表达式匹配。 每个后续成员表示匹配的子表达式。

2、命名匹配的子表达式
以下分组构造捕获匹配的子表达式，并允许你按名称或编号访问它：

(?<name>subexpression)  

(?'name'subexpression)  
其中 name 是有效的组名称，而 子表达式 是任何有效的正则表达式模式。 名称 不得包含任何标点符号字符，并且不能以数字开头。

3、平衡组定义 （太复杂了，我得缓缓）
平衡组定义将删除以前定义的组和存储的定义，并在当前组中存储以前定义的组和当前组之间的间隔。 此分组构造具有以下格式：


(?<name1-name2>subexpression)  

4、非捕获组
以下分组构造不会捕获由子表达式匹配的子字符串：
(?:subexpression) 
这个比较好理解
其中 subexpression 为任何有效正则表达式模式。 当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。

5、组选项（这里的选项太多了，我得专门花时间来看看）


6、零宽度正预测先行断言
以下分组构造定义零宽度正预测先行断言：
(?= 子表达式 )

其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串必须匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。 
零宽度正预测先行断言不会回溯。
通常，零宽度正预测先行断言是在正则表达式模式的末尾找到的。 
它定义了一个子字符串，该子字符串必须出现在匹配字符串的末尾但又不能包含在匹配结果中。 
还有助于防止过度回溯。 可使用零宽度正预测先行断言来确保特定捕获组以与专为该捕获组定义的模式的子集相匹配的文本开始。

这个不是很难理解 
如有以下句子
Hello World aaa
模式：\w+(?=\saaa\b)
结果：World
说明：
\w+   匹配单词
\s    匹配空格
\b    匹配单词边界
匹配aaa之前的单词，单词之后带一个空格，但不包含aaa和这个空格

7、零宽度负预测先行断言
这个其实跟上面是相反的

以下分组构造定义零宽度负预测先行断言：
(?! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串不得匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。
零宽度负预测先行断言通常用在正则表达式的开头或结尾。 
正则表达式的开头可以定义当其定义了要被匹配的相似但更常规的模式时，不应被匹配的特定模式。 
在这种情况下，它通常用于限制回溯。 正则表达式的末尾可以定义不能出现在匹配项末尾处的子表达式。

区别是：
1、零宽度正预测先行断言是匹配输入的字符串，零宽度负预测先行断言是不匹配输入的字符串
2、零宽度正预测先行断言是匹配开头，零宽度负预测先行断言是匹配结尾

如有以下句子
Hello World aaa
模式： \b(?!He)\w+\b
\b     匹配单词边界
(?!He) 确定接下来的两个的字符是否为“He”。 如果没有，则可能匹配。
\w+    匹配单词；
\b     匹配单词边界
匹配不以He开头的接下来的单词，不包含包括He的这个单词

8、零宽度正回顾后发断言

以下分组构造定义零宽度正回顾后发断言：
(?<= 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 必须在输入字符串当前位置左侧出现，尽管 subexpression 未包含在匹配结果中。 零宽度正回顾后发断言不会回溯。
零宽度正预测后发断言通常在正则表达式的开头使用。 它们定义的模式是一个匹配的前提条件，但它不是匹配结果的一部分。

这个其实跟6、零宽度正预测先行断言是刚好相反的，零宽度正预测先行断言是匹配子表达式之前的，零宽度正回顾后发断言是匹配表达式之后的

如有以下句子
Hello World aaa

使用零宽度正预测先行断言
模式：\w+(?=\sWorld\s)
结果：Hello

使用零宽度正回顾后发断言
模式： (?<=\sWorld\s)\w+
结果：aaa

9、零宽度负回顾后发断言

下组构造定义零宽度负回顾后发断言：
(?<! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 不得在输入字符串当前位置的左侧出现。 
但是，任何不匹配 subexpression 的子字符串不包含在匹配结果中。
零宽度负回顾后发断言通常在正则表达式的开头使用。 它们定义的模式预先排除在后面的字符串中的匹配项。 
它们还用于在捕获组中的最后一个或多个字符不得为与该捕获组的正则表达式模式相匹配的其中一个或多个字符时限制回溯。

这个其实跟8、零宽度正回顾后发断言是刚好相反的


零宽度正回顾后发断言要的结果是匹配后的结果 
零宽度负回顾后发断言要的结果是不匹配后的结果

如有以下句子
Monday February 1, 2010
Wednesday February 3, 2010
Saturday February 6, 2010
Sunday February 7, 2010
Monday, February 8, 2010

使用零宽度正回顾后发断言
模式：(?<=(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果：
February 6, 2010
February 7, 2010
说明：
\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?<=(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则继续匹配。
 
使用零宽度负回顾后发断言
模式：(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果
February 1, 2010
February 3, 2010
February 8, 2010

\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?<!(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则匹配成功。

上面两个结果的区别就是
零宽度正回顾后发断言:结果是匹配给定的模式之后的字符串。February 6, 2010是跟在Saturday之后的，February 7, 2010是跟在Sunday之后的
零宽度负回顾后发断言:结果是匹配给定的模式之外的字符串。February 1, 2010，February 3, 2010，February 8, 2010不是跟在Saturday或Sunday之后的



