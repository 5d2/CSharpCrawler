
正则表达式介绍

##################################################################################
正则表达式提供了功能强大、灵活而又高效的方法来处理文本。 
使用正则表达式的全面模式匹配表示法，可以快速分析大量文本，以找到特定的字符模式；
验证文本以确保它匹配预定义模式（如电子邮件地址）；
提取、编辑、替换或删除文本子字符串；
将提取的字符串添加到集合以生成报告。 
对于处理字符串或分析大文本块的许多应用程序而言，正则表达式是不可缺少的工具。
##################################################################################


常规的用法可以参照 ./doc/.Net regular expression quick reference.png
这里也简单列举一下
\a	                 报警 (bell) 符 \u0007 
\b	                 退格键 \u0008 
\t	                 制表符 \u0009 
\r	                 回车符 \u000D （\r 与换行符 \n不是等效的。）
\v	                 垂直制表符 \u000B
\f	                 换页符 \u000C
\n	                 换行符 \u000A
\e	                 转义符 \u001B

\w	                 单词字符
\W	                 非单词字符
\s	                 空白字符
\S	                 非空白字符
\d	                 十进制数字
\D	                 不是十进制数的任意字符

^	                 默认情况下，从字符串的开头开始匹配 在多行模式中，从该行的开头开始匹配
$	                 默认情况下，匹配必须出现在字符串的末尾，或在字符串末尾的 \n 之前 在多行模式中，必须出现在该行的末尾之前，或在该行末尾的 \n 之前
\A	                 从字符串的开头开始匹配
\Z	                 从字符串的末尾或出现在字符串末尾的 \n 之前开始匹配
\z	                 字符串的末尾
\G	                 匹配必须出现在上一个匹配结束的地方。
\b	                 匹配必须出现在 \w （字母数字）和 \W （非字母数字）字符之间的边界上。
\B	                 匹配不得出现在 \b 边界上。

[ character_group ]	 character_group中的任何单个字符。 默认情况下，匹配区分大小写
[^ character_group ] 求反：与不在 character_group 中的任意单个字符匹配。 默认情况下， character_group 中的字符区分大小写
[ first - last ]	 字符范围：与从 first 到 last的范围中的任意单个字符匹配。
.	                 通配符：与除 \n 之外的任意单个字符匹配。若要匹配文本句点字符（. 或 \u002E），你必须在该字符前面加上转义符 (\.)



##############################################################################################################################
正则表达式中的分组构造  https://docs.microsoft.com/en-us/dotnet/standard/base-types/grouping-constructs-in-regular-expressions
##############################################################################################################################

1、匹配的子表达式
以下分组构造捕获匹配的子表达式：
( 子表达式 )
其中 子表达式 为任何有效正则表达式模式。 使用括号的捕获按正则表达式中左括号的顺序从一开始从左到右自动编号。 捕获元素编号为零的捕获是由整个正则表达式模式匹配的文本。


默认情况下， (子表达式) 语言元素捕获匹配的子表达式。 但是，如果正则表达式模式匹配方法的 RegexOptions 参数包含 RegexOptions.ExplicitCapture 标志，或者如果 n 选项应用于此子表达式（参见本主题后面的 组选项 ），则不会捕获匹配的子表达式。
可以四种方法访问捕获的组：
通过使用正则表达式中的反向引用构造。 使用语法 \数字在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获的表达式的初始数字。
通过使用正则表达式中的命名的反向引用构造。 使用语法 \k<name>在同一正则表达式中引用匹配的子表达式，其中 name 是捕获组的名称，或使用 \k<数字>在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获组的初始数字。 捕获组具有与其原始编号相同的默认名称。 
通过使用 $数字 $ Regex.Replace number Match.Result 替换序列，其中 数字 是捕获的表达式的初始数字。
以编程的方式，通过使用 GroupCollection 对象的方式，该对象由 Match.Groups 属性返回。 集合中位置零上的成员表示正则表达式匹配。 每个后续成员表示匹配的子表达式。

2、命名匹配的子表达式
以下分组构造捕获匹配的子表达式，并允许你按名称或编号访问它：

(?<name>subexpression)  

(?'name'subexpression)  
其中 name 是有效的组名称，而 子表达式 是任何有效的正则表达式模式。 名称 不得包含任何标点符号字符，并且不能以数字开头。

3、平衡组定义 （太复杂了，我得缓缓）
平衡组定义将删除以前定义的组和存储的定义，并在当前组中存储以前定义的组和当前组之间的间隔。 此分组构造具有以下格式：


(?<name1-name2>subexpression)  

4、非捕获组
以下分组构造不会捕获由子表达式匹配的子字符串：
(?:subexpression) 
这个比较好理解
其中 subexpression 为任何有效正则表达式模式。 当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。

5、组选项（这里的选项太多了，我得专门花时间来看看）


6、零宽度正预测先行断言
以下分组构造定义零宽度正预测先行断言：
(?= 子表达式 )

其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串必须匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。 
零宽度正预测先行断言不会回溯。
通常，零宽度正预测先行断言是在正则表达式模式的末尾找到的。 
它定义了一个子字符串，该子字符串必须出现在匹配字符串的末尾但又不能包含在匹配结果中。 
还有助于防止过度回溯。 可使用零宽度正预测先行断言来确保特定捕获组以与专为该捕获组定义的模式的子集相匹配的文本开始。

这个不是很难理解 
如有以下句子
Hello World aaa
模式：\w+(?=\saaa\b)
结果：World
说明：
\w+   匹配单词
\s    匹配空格
\b    匹配单词边界
匹配aaa之前的单词，单词之后带一个空格，但不包含aaa和这个空格

7、零宽度负预测先行断言
这个其实跟上面是相反的

以下分组构造定义零宽度负预测先行断言：
(?! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串不得匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。
零宽度负预测先行断言通常用在正则表达式的开头或结尾。 
正则表达式的开头可以定义当其定义了要被匹配的相似但更常规的模式时，不应被匹配的特定模式。 
在这种情况下，它通常用于限制回溯。 正则表达式的末尾可以定义不能出现在匹配项末尾处的子表达式。

区别是：
1、零宽度正预测先行断言是匹配输入的字符串，零宽度负预测先行断言是不匹配输入的字符串
2、零宽度正预测先行断言是匹配开头，零宽度负预测先行断言是匹配结尾

如有以下句子
Hello World aaa
模式： \b(?!He)\w+\b
\b     匹配单词边界
(?!He) 确定接下来的两个的字符是否为“He”。 如果没有，则可能匹配。
\w+    匹配单词；
\b     匹配单词边界
匹配不以He开头的接下来的单词，不包含包括He的这个单词

8、零宽度正回顾后发断言

以下分组构造定义零宽度正回顾后发断言：
(?<= 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 必须在输入字符串当前位置左侧出现，尽管 subexpression 未包含在匹配结果中。 零宽度正回顾后发断言不会回溯。
零宽度正预测后发断言通常在正则表达式的开头使用。 它们定义的模式是一个匹配的前提条件，但它不是匹配结果的一部分。

这个其实跟6、零宽度正预测先行断言是刚好相反的，零宽度正预测先行断言是匹配子表达式之前的，零宽度正回顾后发断言是匹配表达式之后的

如有以下句子
Hello World aaa

使用零宽度正预测先行断言
模式：\w+(?=\sWorld\s)
结果：Hello

使用零宽度正回顾后发断言
模式： (?<=\sWorld\s)\w+
结果：aaa

9、零宽度负回顾后发断言

下组构造定义零宽度负回顾后发断言：
(?<! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 不得在输入字符串当前位置的左侧出现。 
但是，任何不匹配 subexpression 的子字符串不包含在匹配结果中。
零宽度负回顾后发断言通常在正则表达式的开头使用。 它们定义的模式预先排除在后面的字符串中的匹配项。 
它们还用于在捕获组中的最后一个或多个字符不得为与该捕获组的正则表达式模式相匹配的其中一个或多个字符时限制回溯。

这个其实跟8、零宽度正回顾后发断言是刚好相反的


零宽度正回顾后发断言要的结果是匹配后的结果 
零宽度负回顾后发断言要的结果是不匹配后的结果

如有以下句子
Monday February 1, 2010
Wednesday February 3, 2010
Saturday February 6, 2010
Sunday February 7, 2010
Monday, February 8, 2010

使用零宽度正回顾后发断言
模式：(?<=(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果：
February 6, 2010
February 7, 2010
说明：
\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?<=(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则继续匹配。
 
使用零宽度负回顾后发断言
模式：(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果
February 1, 2010
February 3, 2010
February 8, 2010

\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?<!(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则匹配成功。

上面两个结果的区别就是
零宽度正回顾后发断言:结果是匹配给定的模式之后的字符串。February 6, 2010是跟在Saturday之后的，February 7, 2010是跟在Sunday之后的
零宽度负回顾后发断言:结果是匹配给定的模式之外的字符串。February 1, 2010，February 3, 2010，February 8, 2010不是跟在Saturday或Sunday之后的



##############################################################################################################################
正则表达式中的反向引用构造
##############################################################################################################################

1、带编号的反向引用
带编号的反向引用使用以下语法：
\ 数值

其中 number 是正则表达式中捕获组的序号位置。 例如，\4 匹配第四个捕获组的内容。 
如果正则表达式模式中未定义 number，将会发生分析错误，并且正则表达式引擎会抛出 ArgumentException。 
例如，正则表达式 \b(\w+)\s\1 有效，因为 (\w+) 是表达式中的第一个也是唯一一个捕获组。 \b(\w+)\s\2 无效，该表达式会因为没有捕获组编号 \2 而引发自变量异常。
 此外，如果 number 标识特定序号位置中的捕获组，但该捕获组已被分配了一个不同于其序号位置的数字名称，则正则表达式分析器还会引发参数异常

 如有以下句子
 Today is a good dayay

 模式：
 (\w)(\1)
 结果：
 oo
 说明：
  (\w)	匹配单词字符，并将其分配给第一个捕获组。
 (\1)	匹配值与第一捕获组相同的下一个字符。

 模式：
 (\w)(\w)(\1)(\2)
 结果：
 ayay
 说明：
 (\w)	匹配单词字符，并将其分配给第一个捕获组。
 (\w)	匹配单词字符，并将其分配给第二个捕获组。
 (\1)	匹配值与第一捕获组相同的下一个字符。
 (\2)	匹配值与第二捕获组相同的下一个字符。

 2、命名的反向引用
 使用以下语法定义命名的反向引用：
\k< name >

其中，name 是正则表达式模式中定义的捕获组的名称。 如果正则表达式模式中未定义 name，将会发生分析错误，并且正则表达式引擎会抛出参数异常


如有以下句子
Today is a good dayay
模式：
(?<char1>\w)(?<char2>\w)\k<char1>\k<char2>

结果：
ayay

说明：
(?<char1>\w)	匹配字词字符，并将结果分配到 char1 捕获组。
(?<char2>\w)	匹配字词字符，并将结果分配到 char1 捕获组。
\k<char1>	    匹配下一个与 char1 捕获组的值相同的字符。
\k<char2>	    匹配下一个与 char2 捕获组的值相同的字符。

3、已命名数值的反向引用

在具有 \k 的已命名反向引用中，name 也可以是 number 的字符串表示形式。 

如有以下句子
Today is a good dayay
模式：
(?<1>\w)(?<2>\w)\k<1>\k<2>
结果：
ayay

如果 name 是 number 的字符串表示形式，且没有捕获组具有该名称，\k< name > 与反向引用 \number 相同，其中 number 是捕获的序号位置。

如有以下句子
Today is a good dayay
模式：
(?<char>\w)\k<1>
结果：
oo
说明：
(?<char>\w)  匹配字词字符，并将结果分配到 char 捕获组。
\k<1>	     匹配下一个与 第一个捕获组的值相同的字符。因为没有捕获组叫1

如果 name 是 number 的字符串表示形式，并且已向该位置中的捕获组明确分配了数字名称，正则表达式分析器无法通过其序号位置识别捕获组。 
相反，它会引发参数异常。以下示例中的唯一捕获组名为“2”。 由于 \k 结构用于定义名为“1”的反向引用，因此正则表达式分析器无法识别第一个捕获组并引发异常。

模式：
(?<2>\w)\k<1>
结果：
参数异常

4、反向引用匹配什么内容
这个是文档的一部分，写一下。但感觉有点迷

如有以下句子
aababb

模式：
(?<1>a)(?<1>\1b)*

结果：
aababb

说明：
从该字符串的开头开始，成功将“a”与表达式 (?<1>a) 匹配。 此时，1 组的值为“a”。
继续匹配第二个字符，成功将字符串“ab”与表达式 \1b 或“ab”匹配。 然后，将结果“ab”分配到 \1。
继续匹配第四个字符。 表达式 (?<1>\1b)* 要匹配零次或多次，因此会成功将字符串“abb”与表达式 \1b 匹配。 然后，将结果“abb”分配回到 \1。
* 是循环限定符 -- 它将被重复计算，直到正则表达式引擎不能与它定义的模式匹配为止。 循环限定符不会清除组定义。

如有以下句子：
AA22ZZ
AABB

模式：
\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b

结果：
AA22ZZ
AABB

说明：
输入字符串可以匹配此正则表达式，即使第二个捕获组定义的两个十进制数字都不存在。 
即使匹配成功，也仍会在两个成功的捕获组之间找到空捕获组。


