
正则表达式介绍

##################################################################################
正则表达式提供了功能强大、灵活而又高效的方法来处理文本。 
使用正则表达式的全面模式匹配表示法，可以快速分析大量文本，以找到特定的字符模式；
验证文本以确保它匹配预定义模式（如电子邮件地址）；
提取、编辑、替换或删除文本子字符串；
将提取的字符串添加到集合以生成报告。 
对于处理字符串或分析大文本块的许多应用程序而言，正则表达式是不可缺少的工具。
##################################################################################


常规的用法可以参照 ./doc/.Net regular expression quick reference.png
这里也简单列举一下
\a	                 报警 (bell) 符 \u0007 
\b	                 退格键 \u0008 
\t	                 制表符 \u0009 
\r	                 回车符 \u000D （\r 与换行符 \n不是等效的。）
\v	                 垂直制表符 \u000B
\f	                 换页符 \u000C
\n	                 换行符 \u000A
\e	                 转义符 \u001B

\w	                 单词字符
\W	                 非单词字符
\s	                 空白字符
\S	                 非空白字符
\d	                 十进制数字
\D	                 不是十进制数的任意字符

^	                 默认情况下，从字符串的开头开始匹配 在多行模式中，从该行的开头开始匹配
$	                 默认情况下，匹配必须出现在字符串的末尾，或在字符串末尾的 \n 之前 在多行模式中，必须出现在该行的末尾之前，或在该行末尾的 \n 之前
\A	                 从字符串的开头开始匹配
\Z	                 从字符串的末尾或出现在字符串末尾的 \n 之前开始匹配
\z	                 字符串的末尾
\G	                 匹配必须出现在上一个匹配结束的地方。
\b	                 匹配必须出现在 \w （字母数字）和 \W （非字母数字）字符之间的边界上。
\B	                 匹配不得出现在 \b 边界上。

[ character_group ]	 character_group中的任何单个字符。 默认情况下，匹配区分大小写
[^ character_group ] 求反：与不在 character_group 中的任意单个字符匹配。 默认情况下， character_group 中的字符区分大小写
[ first - last ]	 字符范围：与从 first 到 last的范围中的任意单个字符匹配。
.	                 通配符：与除 \n 之外的任意单个字符匹配。若要匹配文本句点字符（. 或 \u002E），你必须在该字符前面加上转义符 (\.)



##############################################################################################################################
正则表达式中的分组构造  https://docs.microsoft.com/en-us/dotnet/standard/base-types/grouping-constructs-in-regular-expressions
##############################################################################################################################

1、匹配的子表达式
以下分组构造捕获匹配的子表达式：
( 子表达式 )
其中 子表达式 为任何有效正则表达式模式。 使用括号的捕获按正则表达式中左括号的顺序从一开始从左到右自动编号。 捕获元素编号为零的捕获是由整个正则表达式模式匹配的文本。


默认情况下， (子表达式) 语言元素捕获匹配的子表达式。 但是，如果正则表达式模式匹配方法的 RegexOptions 参数包含 RegexOptions.ExplicitCapture 标志，或者如果 n 选项应用于此子表达式（参见本主题后面的 组选项 ），则不会捕获匹配的子表达式。
可以四种方法访问捕获的组：
通过使用正则表达式中的反向引用构造。 使用语法 \数字在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获的表达式的初始数字。
通过使用正则表达式中的命名的反向引用构造。 使用语法 \k<name>在同一正则表达式中引用匹配的子表达式，其中 name 是捕获组的名称，或使用 \k<数字>在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获组的初始数字。 捕获组具有与其原始编号相同的默认名称。 
通过使用 $数字 $ Regex.Replace number Match.Result 替换序列，其中 数字 是捕获的表达式的初始数字。
以编程的方式，通过使用 GroupCollection 对象的方式，该对象由 Match.Groups 属性返回。 集合中位置零上的成员表示正则表达式匹配。 每个后续成员表示匹配的子表达式。

2、命名匹配的子表达式
以下分组构造捕获匹配的子表达式，并允许你按名称或编号访问它：

(?<name>subexpression)  

(?'name'subexpression)  
其中 name 是有效的组名称，而 子表达式 是任何有效的正则表达式模式。 名称 不得包含任何标点符号字符，并且不能以数字开头。

3、平衡组定义 （太复杂了，我得缓缓 https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition）
平衡组定义将删除以前定义的组和存储的定义，并在当前组中存储以前定义的组和当前组之间的间隔。 此分组构造具有以下格式：


(?<name1-name2>subexpression)  

name1 位置是当前的组（可选）， name2 是一个以前定义的组，而 子表达式 是任何有效的正则表达式模式。 
平衡组定义删除 name2 的定义并在 name1 中保存 name2 和 name1之间的间隔。 
如果未定义 name2 组，则匹配将回溯。
由于删除 name2 的最后一个定义会显示 name2以前的定义，因此该构造允许将 name2 组的捕获堆栈用作计数器，用于跟踪嵌套构造（如括号或者左括号和右括号）。
平衡组定义将 name2 作为堆栈使用。 将每个嵌套构造的开头字符放在组中，并放在其 Group.Captures 集合中。 
当匹配结束字符时，从组中删除其相应的开始字符，并且 Captures 集合减少 1。 所有嵌套构造的开始和结束字符匹配完后，name2 为空。

这里只能帖上官方的示例了

有如下字符串
<abc><mno<xyz>>

模式：
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  

结果：
<abc><mno<xyz>>

说明：
^	                                            从字符串的开头部分开始。
[^<>]*	                                        匹配零个或多个不是左侧或右侧角度方括号的字符。
(?'Open'<)	                                    匹配左尖括号并分配给名为 Open的组。
[^<>]*	                                        匹配零个或多个不是左侧或右侧角度方括号的字符。
((?'Open'<)[^<>]*) +                            匹配跟在非左尖括号或非右尖括号的零个或多个字符后面的一个或多个左尖括号匹配项。 这是第二个捕获组。
(?'Close-Open'>)	                            匹配右尖括号，将 Open 组和当前组分配给 Close 组并删除 Open 组的定义。
[^<>]*	                                        匹配非左尖括号或非右尖括号的任何字符的零个或多个匹配项。
((?'Close-Open'>)[^<>]*)+	                    匹配跟在零后面或跟在非左尖括号或非右尖括号的多个字符后面的一个或多个右尖括号匹配项。 在匹配右尖括号时，将 Open 组和当前组分配给 Close 组并删除 Open 组的定义。 这是第三个捕获组。
(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*	匹配零个或多个下列模式的匹配项：一个或多个左尖括号匹配项，后跟零个或多个非尖括号字符，后跟一个或多个右尖括号的匹配项，后跟零个或多个非尖括号的匹配项。 在匹配右尖括号时，删除 Open 组的定义，并将 Open 组和当前组之间的子字符串分配给 Close 组。 这是第一个捕获组。
(?(Open)(?!))	                                如果 Open 组存在，并可以匹配空字符串，则放弃匹配，但不前移字符串中的正则表达式引擎的位置。 这是零宽度负预测先行断言。 因为空字符串总是隐式地存在于输入字符串中，所以此匹配始终失败。 此匹配的失败表示尖括号不平衡。
$	                                            匹配输入字符串的末尾部分。


4、非捕获组
以下分组构造不会捕获由子表达式匹配的子字符串：
(?:subexpression) 
这个比较好理解
其中 subexpression 为任何有效正则表达式模式。 当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。

5、组选项

应用正则表达式的选项有三种方法。第一种方法最简单粗暴，所以后面两种也不具体学习了

方法一、

可以通过
Regex.Match(String, String, RegexOptions)
这个重载来实现组选项
https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regexoptions?view=netframework-4.8

如
Regex.Match("input","pattern",RegexOptions.IgnorCase);   //忽略大小写

RegexOptions成员	          内联字符	         效果
None	                      不可用             使用默认行为。 有关更多信息，请参见默认选项。
IgnoreCase	                  i	                 使用不区分大小写的匹配。 有关更多信息，请参见不区分大小写的匹配。
Multiline	                  m	                 使用多线模式，其中 ^ 和 $ 匹配每行的开头和末尾（不是输入字符串的开头和末尾）。 有关更多信息，请参见多行模式。
Singleline	                  s	                 使用单行模式，其中的句号 (.) 匹配每个字符（而不是除了 \n 以外的每个字符)。 有关更多信息，请参见单行模式。
ExplicitCapture	              n	                 不捕获未命名的组。 唯一有效的捕获是显式命名或编号的 (?<name> subexpression) 形式的组。 有关更多信息，请参见仅显式捕获。
Compiled	                  不可用	         将正则表达式编译为程序集。 有关更多信息，请参见已编译的正则表达式。
IgnorePatternWhitespace       x	                 从模式中排除保留的空白并启用数字符号 (#) 后的注释。 有关更多信息，请参见忽略空白。
RightToLeft	                  不可用	         更改搜索方向。 搜索是从右向左而不是从左向右进行。 有关更多信息，请参见从右向左模式。
ECMAScript	                  不可用	         为表达式启用符合 ECMAScript 的行为。 有关更多信息，请参见 ECMAScript 匹配行为。
CultureInvariant              不可用	         忽略语言的区域性差异
 
方法二、
通过在包含语法 (?imnsx-imnsx) 的正则表达式模式中应用内联选项。 该选项从选项定义为模式末尾的点应用于该模式，或应用于另一内联选项未定义选项的点。

如：
 (?ix) d \w+ \s

方法三、
通过在包含语法 (?imnsx-imnsx:subexpression) 的正则表达式模式的特定分组构造中，应用内联选项。 一组选项前面没有符号用于打开该设置；一组选项前面的减号用于关闭该设置。 （无论选项是启用还是禁用，? 都是所需的语言构造语法的固定部分。）选项只应用于该组。

如：
\b(?ix: d \w+)\s

说明：
如果构造函数或方法调用的 options 形参中指定的正则表达式选项与正则表达式模式中的内联指定的选项冲突，那么将使用该内联选项。


下面说明一下各选项

默认选项：
正则表达式引擎使用其默认行为。 这包括：
该模式将被解释为一个规范而非 ECMAScript 正则表达式。
从左到右在输入字符串中匹配的正则表达式模式。
比较区分大小写。
^ 和 $ 语言元素与输入字符串的开头和结尾匹配。
. 语言元素与除 \n 之外的每个字符匹配。
正则表达式模式中的任意空白均解释为文本空白字符。
将模式与输入字符串进行比较时将使用当前区域性的约定。
正则表达式模式中的捕获组可以是隐式的，也可以是显式的。

不区分大小写的匹配：
IgnoreCase 或 (?i:xx)

字符串：
The man then told them about that event.
模式:
\b(?i:t)he\w*\b
结果
The
then
them

多行模式
待更新


6、零宽度正预测先行断言
以下分组构造定义零宽度正预测先行断言：
(?= 子表达式 )

其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串必须匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。 
零宽度正预测先行断言不会回溯。
通常，零宽度正预测先行断言是在正则表达式模式的末尾找到的。 
它定义了一个子字符串，该子字符串必须出现在匹配字符串的末尾但又不能包含在匹配结果中。 
还有助于防止过度回溯。 可使用零宽度正预测先行断言来确保特定捕获组以与专为该捕获组定义的模式的子集相匹配的文本开始。

这个不是很难理解 
如有以下句子
Hello World aaa
模式：\w+(?=\saaa\b)
结果：World
说明：
\w+   匹配单词
\s    匹配空格
\b    匹配单词边界
匹配aaa之前的单词，单词之后带一个空格，但不包含aaa和这个空格

7、零宽度负预测先行断言
这个其实跟上面是相反的

以下分组构造定义零宽度负预测先行断言：
(?! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串不得匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。
零宽度负预测先行断言通常用在正则表达式的开头或结尾。 
正则表达式的开头可以定义当其定义了要被匹配的相似但更常规的模式时，不应被匹配的特定模式。 
在这种情况下，它通常用于限制回溯。 正则表达式的末尾可以定义不能出现在匹配项末尾处的子表达式。

区别是：
1、零宽度正预测先行断言是匹配输入的字符串，零宽度负预测先行断言是不匹配输入的字符串
2、零宽度正预测先行断言是匹配开头，零宽度负预测先行断言是匹配结尾

如有以下句子
Hello World aaa
模式： \b(?!He)\w+\b
\b     匹配单词边界
(?!He) 确定接下来的两个的字符是否为“He”。 如果没有，则可能匹配。
\w+    匹配单词；
\b     匹配单词边界
匹配不以He开头的接下来的单词，不包含包括He的这个单词

8、零宽度正回顾后发断言

以下分组构造定义零宽度正回顾后发断言：
(?<= 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 必须在输入字符串当前位置左侧出现，尽管 subexpression 未包含在匹配结果中。 零宽度正回顾后发断言不会回溯。
零宽度正预测后发断言通常在正则表达式的开头使用。 它们定义的模式是一个匹配的前提条件，但它不是匹配结果的一部分。

这个其实跟6、零宽度正预测先行断言是刚好相反的，零宽度正预测先行断言是匹配子表达式之前的，零宽度正回顾后发断言是匹配表达式之后的

如有以下句子
Hello World aaa

使用零宽度正预测先行断言
模式：\w+(?=\sWorld\s)
结果：Hello

使用零宽度正回顾后发断言
模式： (?<=\sWorld\s)\w+
结果：aaa

9、零宽度负回顾后发断言

下组构造定义零宽度负回顾后发断言：
(?<! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 不得在输入字符串当前位置的左侧出现。 
但是，任何不匹配 subexpression 的子字符串不包含在匹配结果中。
零宽度负回顾后发断言通常在正则表达式的开头使用。 它们定义的模式预先排除在后面的字符串中的匹配项。 
它们还用于在捕获组中的最后一个或多个字符不得为与该捕获组的正则表达式模式相匹配的其中一个或多个字符时限制回溯。

这个其实跟8、零宽度正回顾后发断言是刚好相反的


零宽度正回顾后发断言要的结果是匹配后的结果 
零宽度负回顾后发断言要的结果是不匹配后的结果

如有以下句子
Monday February 1, 2010
Wednesday February 3, 2010
Saturday February 6, 2010
Sunday February 7, 2010
Monday, February 8, 2010

使用零宽度正回顾后发断言
模式：(?<=(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果：
February 6, 2010
February 7, 2010
说明：
\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?<=(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则继续匹配。
 
使用零宽度负回顾后发断言
模式：(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果
February 1, 2010
February 3, 2010
February 8, 2010

\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?<!(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则匹配成功。

上面两个结果的区别就是
零宽度正回顾后发断言:结果是匹配给定的模式之后的字符串。February 6, 2010是跟在Saturday之后的，February 7, 2010是跟在Sunday之后的
零宽度负回顾后发断言:结果是匹配给定的模式之外的字符串。February 1, 2010，February 3, 2010，February 8, 2010不是跟在Saturday或Sunday之后的



##############################################################################################################################
正则表达式中的反向引用构造
##############################################################################################################################

1、带编号的反向引用
带编号的反向引用使用以下语法：
\ 数值

其中 number 是正则表达式中捕获组的序号位置。 例如，\4 匹配第四个捕获组的内容。 
如果正则表达式模式中未定义 number，将会发生分析错误，并且正则表达式引擎会抛出 ArgumentException。 
例如，正则表达式 \b(\w+)\s\1 有效，因为 (\w+) 是表达式中的第一个也是唯一一个捕获组。 \b(\w+)\s\2 无效，该表达式会因为没有捕获组编号 \2 而引发自变量异常。
 此外，如果 number 标识特定序号位置中的捕获组，但该捕获组已被分配了一个不同于其序号位置的数字名称，则正则表达式分析器还会引发参数异常

 如有以下句子
 Today is a good dayay

 模式：
 (\w)(\1)
 结果：
 oo
 说明：
  (\w)	匹配单词字符，并将其分配给第一个捕获组。
 (\1)	匹配值与第一捕获组相同的下一个字符。

 模式：
 (\w)(\w)(\1)(\2)
 结果：
 ayay
 说明：
 (\w)	匹配单词字符，并将其分配给第一个捕获组。
 (\w)	匹配单词字符，并将其分配给第二个捕获组。
 (\1)	匹配值与第一捕获组相同的下一个字符。
 (\2)	匹配值与第二捕获组相同的下一个字符。

 2、命名的反向引用
 使用以下语法定义命名的反向引用：
\k< name >

其中，name 是正则表达式模式中定义的捕获组的名称。 如果正则表达式模式中未定义 name，将会发生分析错误，并且正则表达式引擎会抛出参数异常


如有以下句子
Today is a good dayay
模式：
(?<char1>\w)(?<char2>\w)\k<char1>\k<char2>

结果：
ayay

说明：
(?<char1>\w)	匹配字词字符，并将结果分配到 char1 捕获组。
(?<char2>\w)	匹配字词字符，并将结果分配到 char1 捕获组。
\k<char1>	    匹配下一个与 char1 捕获组的值相同的字符。
\k<char2>	    匹配下一个与 char2 捕获组的值相同的字符。

3、已命名数值的反向引用

在具有 \k 的已命名反向引用中，name 也可以是 number 的字符串表示形式。 

如有以下句子
Today is a good dayay
模式：
(?<1>\w)(?<2>\w)\k<1>\k<2>
结果：
ayay

如果 name 是 number 的字符串表示形式，且没有捕获组具有该名称，\k< name > 与反向引用 \number 相同，其中 number 是捕获的序号位置。

如有以下句子
Today is a good dayay
模式：
(?<char>\w)\k<1>
结果：
oo
说明：
(?<char>\w)  匹配字词字符，并将结果分配到 char 捕获组。
\k<1>	     匹配下一个与 第一个捕获组的值相同的字符。因为没有捕获组叫1

如果 name 是 number 的字符串表示形式，并且已向该位置中的捕获组明确分配了数字名称，正则表达式分析器无法通过其序号位置识别捕获组。 
相反，它会引发参数异常。以下示例中的唯一捕获组名为“2”。 由于 \k 结构用于定义名为“1”的反向引用，因此正则表达式分析器无法识别第一个捕获组并引发异常。

模式：
(?<2>\w)\k<1>
结果：
参数异常

4、反向引用匹配什么内容
这个是文档的一部分，写一下。但感觉有点迷

如有以下句子
aababb

模式：
(?<1>a)(?<1>\1b)*

结果：
aababb

说明：
从该字符串的开头开始，成功将“a”与表达式 (?<1>a) 匹配。 此时，1 组的值为“a”。
继续匹配第二个字符，成功将字符串“ab”与表达式 \1b 或“ab”匹配。 然后，将结果“ab”分配到 \1。
继续匹配第四个字符。 表达式 (?<1>\1b)* 要匹配零次或多次，因此会成功将字符串“abb”与表达式 \1b 匹配。 然后，将结果“abb”分配回到 \1。
* 是循环限定符 -- 它将被重复计算，直到正则表达式引擎不能与它定义的模式匹配为止。 循环限定符不会清除组定义。

如有以下句子：
AA22ZZ
AABB

模式：
\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b

结果：
AA22ZZ
AABB

说明：
输入字符串可以匹配此正则表达式，即使第二个捕获组定义的两个十进制数字都不存在。 
即使匹配成功，也仍会在两个成功的捕获组之间找到空捕获组。


