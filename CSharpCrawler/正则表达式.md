
# 正则表达式介绍


* 正则表达式提供了功能强大、灵活而又高效的方法来处理文本。 
* 使用正则表达式的全面模式匹配表示法，可以快速分析大量文本，以找到特定的字符模式；
* 验证文本以确保它匹配预定义模式（如电子邮件地址）；
* 提取、编辑、替换或删除文本子字符串；
* 将提取的字符串添加到集合以生成报告。 
* 对于处理字符串或分析大文本块的许多应用程序而言，正则表达式是不可缺少的工具。



## 常规的用法可以参照 [.Net regular expression quick reference.png](https://github.com/zhaotianff/CSharpCrawler/blob/master/CSharpCrawler/doc/.Net%20regular%20expression%20quick%20reference.png)


这里也简单列举一下

转义字符|说明
--|--:
\a|	                 报警 (bell) 符 \u0007 
\b|	                 退格键 \u0008 
\t|	                 制表符 \u0009 
\r|	                 回车符 \u000D （\r 与换行符 \n不是等效的。）
\v|	                 垂直制表符 \u000B
\f|	                 换页符 \u000C
\n|	                 换行符 \u000A
\e|	                 转义符 \u001B
" "|" "
\w|	                 单词字符
\W|	                 非单词字符
\s|	                 空白字符
\S|	                 非空白字符
\d|	                 十进制数字
\D|	                 不是十进制数的任意字符
" "|" "
^|	                 默认情况下，从字符串的开头开始匹配 在多行模式中，从该行的开头开始匹配
$|	                 默认情况下，匹配必须出现在字符串的末尾，或在字符串末尾的 \n 之前 在多行模式中，必须出现在该行的末尾之前，或在该行末尾的 \n 之前
\A|	                 从字符串的开头开始匹配
\Z|	                 从字符串的末尾或出现在字符串末尾的 \n 之前开始匹配
\z|	                 字符串的末尾
\G|	                 匹配必须出现在上一个匹配结束的地方。
\b|	                 匹配必须出现在 \w （字母数字）和 \W （非字母数字）字符之间的边界上。
\B|	                 匹配不得出现在 \b 边界上。
" "|" "
[ character_group ]|	 character_group中的任何单个字符。 默认情况下，匹配区分大小写
[^ character_group ]| 求反：与不在 character_group 中的任意单个字符匹配。 默认情况下， character_group 中的字符区分大小写
[ first - last ]|	 字符范围：与从 first 到 last的范围中的任意单个字符匹配。
.|	                 通配符：与除 \n 之外的任意单个字符匹配。若要匹配文本句点字符（. 或 \u002E），你必须在该字符前面加上转义符 (\.)




## 正则表达式中的分组构造  
https://docs.microsoft.com/en-us/dotnet/standard/base-types/grouping-constructs-in-regular-expressions


* 匹配的子表达式

    以下分组构造捕获匹配的子表达式：

    ( 子表达式 )

    其中 子表达式 为任何有效正则表达式模式。使用括号的捕获按正则表达式中左括号的顺序从一开始从左到右自动编号。 捕获元素编号为零的捕获是由整个正则表达式模式匹配的文本。


    默认情况下， (子表达式) 语言元素捕获匹配的子表达式。 但是，如果正则表达式模式匹配方法的 RegexOptions 参数包含 RegexOptions.ExplicitCapture 标志，或者如果 n 选项应用于此子表达式（参见本主题后面的 组选项 ），则不会捕获匹配的子表达式。

    **可以四种方法访问捕获的组：**

  1. 通过使用正则表达式中的反向引用构造。 使用语法 \数字在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获的表达式的初始数字。

  2. 通过使用正则表达式中的命名的反向引用构造。 使用语法 \k&lt;name&gt;在同一正则表达式中引用匹配的子表达式，其中 name 是捕获组的名称，或使用 \k&lt;数字&gt;在同一正则表达式中引用匹配的子表达式，其中 数字 是捕获组的初始数字。 捕获组具有与其原始编号相同的默认名称。 

  3. 通过使用 $数字 $ Regex.Replace number Match.Result 替换序列，其中 数字 是捕获的表达式的初始数字。
以编程的方式，通过使用 GroupCollection 对象的方式，该对象由 Match.Groups 属性返回。 集合中位置零上的成员表示正则表达式匹配。 每个后续成员表示匹配的子表达式。

* 命名匹配的子表达式

  以下分组构造捕获匹配的子表达式，并允许你按名称或编号访问它：

  *(?&lt;name&gt;subexpression)*  

  *(?'name'subexpression)*  

  其中 name 是有效的组名称，而 子表达式 是任何有效的正则表达式模式。 名称 不得包含任何标点符号字符，并且不能以数字开头。


* 平衡组定义 （https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition）

  平衡组定义将删除以前定义的组和存储的定义，并在当前组中存储以前定义的组和当前组之间的间隔。 此分组构造具有以下格式：


  *(?&lt;name1-name2&gt;subexpression)*  

  name1 位置是当前的组（可选）， name2 是一个以前定义的组，而 子表达式 是任何有效的正则表达式模式。 

  平衡组定义删除 name2 的定义并在 name1 中保存 name2 和 name1之间的间隔。 

  如果未定义 name2 组，则匹配将回溯。

  由于删除 name2 的最后一个定义会显示 name2以前的定义，因此该构造允许将 name2 组的捕获堆栈用作计数器，用于跟踪嵌套构造（如括号或者左括号和右括号）。

  平衡组定义将 name2 作为堆栈使用。 将每个嵌套构造的开头字符放在组中，并放在其 Group.Captures 集合中。 

  当匹配结束字符时，从组中删除其相应的开始字符，并且 Captures 集合减少 1。 所有嵌套构造的开始和结束字符匹配完后，name2 为空。

  这里只能帖上官方的示例了

  有如下字符串  
  &lt;abc&gt;&lt;mno&lt;xyz&gt;&gt;  

  模式：  
  *^[^&lt;&gt;]*(((?'Open'&lt;)[^&lt;&gt;]*)+((?'Close-Open'&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))$*  

  结果：  
  &lt;abc&gt;&lt;mno&lt;xyz&gt;&gt;

  说明：
  
模式|说明
--|--:
^|	                                            从字符串的开头部分开始。
[^&lt;&gt;]*|	                                        匹配零个或多个不是左侧或右侧角度方括号的字符。
(?'Open'&lt;)|	                                    匹配左尖括号并分配给名为 Open的组。
[^&lt;&gt;]*|	                                        匹配零个或多个不是左侧或右侧角度方括号的字符。
((?'Open'&lt;)[^&lt;&gt;]*) +|                            匹配跟在非左尖括号或非右尖括号的零个或多个字符后面的一个或多个左尖括号匹配项。 这是第二个捕获组。
(?'Close-Open'&gt;)|	                            匹配右尖括号，将 Open 组和当前组分配给 Close 组并删除 Open 组的定义。
[^&lt;&gt;]*|	                                        匹配非左尖括号或非右尖括号的任何字符的零个或多个匹配项。
((?'Close-Open'&gt;)[^&lt;&gt;]*)+|	                    匹配跟在零后面或跟在非左尖括号或非右尖括号的多个字符后面的一个或多个右尖括号匹配项。 在匹配右尖括号时，将 Open 组和当前组分配给 Close 组并删除 Open 组的定义。 这是第三个捕获组。
(((?'Open'&lt;)[^&lt;&gt;]*)+((?'Close-Open'&gt;)[^&lt;&gt;]*)+)*|	匹配零个或多个下列模式的匹配项：一个或多个左尖括号匹配项，后跟零个或多个非尖括号字符，后跟一个或多个右尖括号的匹配项，后跟零个或多个非尖括号的匹配项。 在匹配右尖括号时，删除 Open 组的定义，并将 Open 组和当前组之间的子字符串分配给 Close 组。 这是第一个捕获组。
(?(Open)(?!))|	                                如果 Open 组存在，并可以匹配空字符串，则放弃匹配，但不前移字符串中的正则表达式引擎的位置。 这是零宽度负预测先行断言。 因为空字符串总是隐式地存在于输入字符串中，所以此匹配始终失败。 此匹配的失败表示尖括号不平衡。
$|	                                            匹配输入字符串的末尾部分。


* 非捕获组

  以下分组构造不会捕获由子表达式匹配的子字符串：

  *(?:subexpression)* 

  这个比较好理解  
  其中 subexpression 为任何有效正则表达式模式。 当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。

* 组选项

  应用正则表达式的选项有三种方法。第一种方法最简单粗暴，所以后面两种也不具体学习了

  1.  方法一  

      可以通过  
      Regex.Match(String, String, RegexOptions)  
      这个重载来实现组选项  
      https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regexoptions?view=netframework-4.8

      如  
      Regex.Match("input","pattern",RegexOptions.IgnorCase);   //忽略大小写

RegexOptions成员|	          内联字符|	         效果
--|:--:|--:
None|	                      不可用|             使用默认行为。 有关更多信息，请参见默认选项。
IgnoreCase|	                  i|	                 使用不区分大小写的匹配。 有关更多信息，请参见不区分大小写的匹配。
Multiline|	                  m|	                 使用多线模式，其中 ^ 和 $ 匹配每行的开头和末尾（不是输入字符串的开头和末尾）。 有关更多信息，请参见多行模式。
Singleline|	                  s|	                 使用单行模式，其中的句号 (.) 匹配每个字符（而不是除了 \n 以外的每个字符)。 有关更多信息，请参见单行模式。
ExplicitCapture|	              n|	                 不捕获未命名的组。 唯一有效的捕获是显式命名或编号的 (?&lt;name&gt; subexpression) 形式的组。 有关更多信息，请参见仅显式捕获。
Compiled|	                  不可用|	         将正则表达式编译为程序集。 有关更多信息，请参见已编译的正则表达式。
IgnorePatternWhitespace|       x|	                 从模式中排除保留的空白并启用数字符号 (#) 后的注释。 有关更多信息，请参见忽略空白。
RightToLeft	|                  不可用	|         更改搜索方向。 搜索是从右向左而不是从左向右进行。 有关更多信息，请参见从右向左模式。
ECMAScript|	                  不可用|	         为表达式启用符合 ECMAScript 的行为。 有关更多信息，请参见 ECMAScript 匹配行为。
CultureInvariant |             不可用|	         忽略语言的区域性差异

  2.  方法二

    通过在包含语法 (?imnsx-imnsx) 的正则表达式模式中应用内联选项。 该选项从选项定义为模式末尾的点应用于该模式，或应用于另一内联选项未定义选项的点。

    如：  
    *(?ix) d \w+ \s*

    方法三、  
    通过在包含语法 (?imnsx-imnsx:subexpression) 的正则表达式模式的特定分组构造中，应用内联选项。 一组选项前面没有符号用于打开该设置；一组选项前面的减号用于关闭该设置。 （无论选项是启用还是禁用，? 都是所需的语言构造语法的固定部分。）选项只应用于该组。

    如：  
    *\b(?ix: d \w+)\s*

    说明：  
    如果构造函数或方法调用的 options 形参中指定的正则表达式选项与正则表达式模式中的内联指定的选项冲突，那么将使用该内联选项。


    ### 下面说明一下各选项

    **默认选项：**  
    正则表达式引擎使用其默认行为。  

    这包括：  

    *该模式将被解释为一个规范而非 ECMAScript 正则表达式。*  
    *从左到右在输入字符串中匹配的正则表达式模式。*  
    *比较区分大小写。*  
    *^ 和 $ 语言元素与输入字符串的开头和结尾匹配。*  
    *. 语言元素与除 \n 之外的每个字符匹配。*  
    *正则表达式模式中的任意空白均解释为文本空白字符。*  
    *将模式与输入字符串进行比较时将使用当前区域性的约定。*  
    *正则表达式模式中的捕获组可以是隐式的，也可以是显式的。*  

    **不区分大小写的匹配：**  
    *IgnoreCase 或 (?i:xx)*

    字符串：  
    *The man then told them about that event.*  
    模式:  
    *\b(?i:t)he\w*\b*  
    结果  
    *The*  
    *then*  
    *them*  
    说明：
    使用 *(?i:t)* 不区分t的大小写

    **多行模式**  
    它更改了 ^ 和 $ 语言元素的解释，以使它们分别与行的开头和结尾匹配，而不是与输入字符串的开头和结尾匹配。   
    默认情况下，$ 仅与输入字符串的末尾匹配。   
    如果指定了 RegexOptions.Multiline 选项，它将与换行符 *(\n)* 或输入字符串的末尾匹配。 但是，它并不与回车符/换行符的组合匹配。 若要成功匹配它们，使用子表达式 *\r?$* 来代替 *$*。

    Multiline 或 *(?m)*  
    字符串：  
    *"Joe 164\nSam 208\nAllison 211\nGwen 171\n";*   
    模式：  
    *(?m)^(\w+)\s(\d+)\r*$*  
    结果  
    *Allison: 211*  
    *Sam: 208*  
    *Gwen: 171*  
    *Joe: 164*
说明：
(?m) 开启多行模式
\r   匹配回车
$    代表每一行的结尾

单行模式
它通过更改时间段 (.) 语言元素的行为，使其与每个字符匹配，而不是与除换行符 \n 或 \u000A 之外的每个字符匹配来执行此操作。

Singleline 或 (?s)
  
字符串
This is one line and
this is the second.     
模式：
(?s)^.+
结果：
This is one line and
this is the second. 
说明：
如果不使用单行模式，匹配的结果只有This is one line and，因为(.)通配符不会与\n匹配

仅显式捕获

默认情况下，通过在正则表达式模式中使用括号来定义捕获组。
通过 (?&lt;name&gt;subexpression) 语言选项为命名组指定名称或编号，而未命名组按索引进行访问。 
在 GroupCollection 对象中，未命名的组先于已命名的组。
分组构造通常仅用于将限定符应用于多个语言元素，而非应用于捕获的子字符串。

 ExplicitCapture 或 (?n) 

 这个其实就是没命名的组不捕获
 示例比较多，这里不贴出来了，知道这个意思 就行了

已编译的正则表达式

默认情况下，.NET 中的正则表达式会有解释。 
当实例化 Regex 对象或者调用静态 Regex 方法时，将把正则表达式模式解析为一组自定义操作代码，并且解释器使用这些操作代码来运行正则表达式。 
这涉及一个权衡：初始化正则表达式引擎的成本通过运行时性能的消耗而最小化。
通过使用 RegexOptions.Compiled 选项可以使用编译的而非解释的正则表达式。 
在此情况下，当模式传递给正则表达式引擎时，它将分析为一组操作码，然后转换为 Microsoft 中间语言 (MSIL)，该语言可以被直接传递到公共语言运行时。 
已编译的正则表达式最大限度地提高运行时性能，代价是会影响初始化时间。

忽略空白

1、正则表达式模式中的非转义的空白将被忽略。 作为正则表达式模式的部分，必须避开空白字符（例如 \s 或“\”）。
2、数字符号 (#) 被解释为注释的开头，而不是原义字符。 正则表达式模式中的所有文本，从 # 字符到字符串的结尾都解释为注释。但是，在下列情况下，不会忽略正则表达式中的空白字符，即使使用 RegexOptions.IgnorePatternWhitespace 选项也是如此：
3、始终按原义解释字符内的空格。 例如，正则表达式模式 [ .,;:] 匹配任意单个空白字符、句号、逗号、分号或冒号。
4、加括号的限定符内不允许有空格，如 {n}、{n,} 和 {n,m}。 例如，因为它包含一个空白字符，所以正则表达式模式 \d{1, 3} 与任何从 1 到 3 位数的数字序列不匹配。
5、引入语言元素的字符序列内不允许有空格。 例如:
	一、语言元素 (?:subexpression) 表示非捕获组，并且该元素的 (?: 部分不能有嵌入空格。 模式 (? :子表达式) 在运行时抛出 ArgumentException，因为正则表达式引擎无法分析此模式，且模式 ( ?:子表达式) 与子表达式不匹配。
	二、语言元素 \p{name} 表示一个 Unicode 类别或命名块，它不能在元素的 \p{ 部分中包括嵌入空格。 如果你包括了空格，则该元素会在运行时引发 ArgumentException 异常。

IgnorePatternWhitespace 或 (?x)

从右到左模式

更改搜索方向
需要注意的是
预测先行断言（(?=subexpression) 语言元素）和回顾后发断言（(?&lt;=subexpression) 语言元素）不会更改方向。 预测先行断言向右搜索；回顾后发断言向左搜索。


ECMAScript 匹配行为
https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-options#ecmascript-matching-behavior

使用固定区域性的比较
https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-options#comparison-using-the-invariant-culture



6、零宽度正预测先行断言
以下分组构造定义零宽度正预测先行断言：
(?= 子表达式 )

其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串必须匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。 
零宽度正预测先行断言不会回溯。
通常，零宽度正预测先行断言是在正则表达式模式的末尾找到的。 
它定义了一个子字符串，该子字符串必须出现在匹配字符串的末尾但又不能包含在匹配结果中。 
还有助于防止过度回溯。 可使用零宽度正预测先行断言来确保特定捕获组以与专为该捕获组定义的模式的子集相匹配的文本开始。

这个不是很难理解 
如有以下句子
Hello World aaa
模式：\w+(?=\saaa\b)
结果：World
说明：
\w+   匹配单词
\s    匹配空格
\b    匹配单词边界
匹配aaa之前的单词，单词之后带一个空格，但不包含aaa和这个空格

7、零宽度负预测先行断言
这个其实跟上面是相反的

以下分组构造定义零宽度负预测先行断言：
(?! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则输入字符串不得匹配 子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。
零宽度负预测先行断言通常用在正则表达式的开头或结尾。 
正则表达式的开头可以定义当其定义了要被匹配的相似但更常规的模式时，不应被匹配的特定模式。 
在这种情况下，它通常用于限制回溯。 正则表达式的末尾可以定义不能出现在匹配项末尾处的子表达式。

区别是：
1、零宽度正预测先行断言是匹配输入的字符串，零宽度负预测先行断言是不匹配输入的字符串
2、零宽度正预测先行断言是匹配开头，零宽度负预测先行断言是匹配结尾

如有以下句子
Hello World aaa
模式： \b(?!He)\w+\b
\b     匹配单词边界
(?!He) 确定接下来的两个的字符是否为“He”。 如果没有，则可能匹配。
\w+    匹配单词；
\b     匹配单词边界
匹配不以He开头的接下来的单词，不包含包括He的这个单词

8、零宽度正回顾后发断言

以下分组构造定义零宽度正回顾后发断言：
(?&lt;= 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 必须在输入字符串当前位置左侧出现，尽管 subexpression 未包含在匹配结果中。 零宽度正回顾后发断言不会回溯。
零宽度正预测后发断言通常在正则表达式的开头使用。 它们定义的模式是一个匹配的前提条件，但它不是匹配结果的一部分。

这个其实跟6、零宽度正预测先行断言是刚好相反的，零宽度正预测先行断言是匹配子表达式之前的，零宽度正回顾后发断言是匹配表达式之后的

如有以下句子
Hello World aaa

使用零宽度正预测先行断言
模式：\w+(?=\sWorld\s)
结果：Hello

使用零宽度正回顾后发断言
模式： (?&lt;=\sWorld\s)\w+
结果：aaa

9、零宽度负回顾后发断言

下组构造定义零宽度负回顾后发断言：
(?&lt;! 子表达式 )
其中 子表达式 为任何正则表达式模式。 若要成功匹配，则 子表达式 不得在输入字符串当前位置的左侧出现。 
但是，任何不匹配 subexpression 的子字符串不包含在匹配结果中。
零宽度负回顾后发断言通常在正则表达式的开头使用。 它们定义的模式预先排除在后面的字符串中的匹配项。 
它们还用于在捕获组中的最后一个或多个字符不得为与该捕获组的正则表达式模式相匹配的其中一个或多个字符时限制回溯。

这个其实跟8、零宽度正回顾后发断言是刚好相反的


零宽度正回顾后发断言要的结果是匹配后的结果 
零宽度负回顾后发断言要的结果是不匹配后的结果

如有以下句子
Monday February 1, 2010
Wednesday February 3, 2010
Saturday February 6, 2010
Sunday February 7, 2010
Monday, February 8, 2010

使用零宽度正回顾后发断言
模式：(?&lt;=(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果：
February 6, 2010
February 7, 2010
说明：
\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?&lt;=(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则继续匹配。
 
使用零宽度负回顾后发断言
模式：(?&lt;!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
结果
February 1, 2010
February 3, 2010
February 8, 2010

\b	在单词边界处开始匹配。
\w+	匹配一个或多个后跟空白字符的单词字符。
\d{1,2},	匹配空白字符和逗号后面的一个或两个十进制数字。
\d{4}\b	匹配四个十进制数字并在单词边界处结束匹配。
(?&lt;!(Saturday|Sunday) )	如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则匹配成功。

上面两个结果的区别就是
零宽度正回顾后发断言:结果是匹配给定的模式之后的字符串。February 6, 2010是跟在Saturday之后的，February 7, 2010是跟在Sunday之后的
零宽度负回顾后发断言:结果是匹配给定的模式之外的字符串。February 1, 2010，February 3, 2010，February 8, 2010不是跟在Saturday或Sunday之后的



##############################################################################################################################
正则表达式中的反向引用构造
##############################################################################################################################

1、带编号的反向引用
带编号的反向引用使用以下语法：
\ 数值

其中 number 是正则表达式中捕获组的序号位置。 例如，\4 匹配第四个捕获组的内容。 
如果正则表达式模式中未定义 number，将会发生分析错误，并且正则表达式引擎会抛出 ArgumentException。 
例如，正则表达式 \b(\w+)\s\1 有效，因为 (\w+) 是表达式中的第一个也是唯一一个捕获组。 \b(\w+)\s\2 无效，该表达式会因为没有捕获组编号 \2 而引发自变量异常。
 此外，如果 number 标识特定序号位置中的捕获组，但该捕获组已被分配了一个不同于其序号位置的数字名称，则正则表达式分析器还会引发参数异常

 如有以下句子
 Today is a good dayay

 模式：
 (\w)(\1)
 结果：
 oo
 说明：
  (\w)	匹配单词字符，并将其分配给第一个捕获组。
 (\1)	匹配值与第一捕获组相同的下一个字符。

 模式：
 (\w)(\w)(\1)(\2)
 结果：
 ayay
 说明：
 (\w)	匹配单词字符，并将其分配给第一个捕获组。
 (\w)	匹配单词字符，并将其分配给第二个捕获组。
 (\1)	匹配值与第一捕获组相同的下一个字符。
 (\2)	匹配值与第二捕获组相同的下一个字符。

 2、命名的反向引用
 使用以下语法定义命名的反向引用：
\k&lt; name &gt;

其中，name 是正则表达式模式中定义的捕获组的名称。 如果正则表达式模式中未定义 name，将会发生分析错误，并且正则表达式引擎会抛出参数异常


如有以下句子
Today is a good dayay
模式：
(?&lt;char1&gt;\w)(?&lt;char2&gt;\w)\k&lt;char1&gt;\k&lt;char2&gt;

结果：
ayay

说明：
(?&lt;char1&gt;\w)	匹配字词字符，并将结果分配到 char1 捕获组。
(?&lt;char2&gt;\w)	匹配字词字符，并将结果分配到 char1 捕获组。
\k&lt;char1&gt;	    匹配下一个与 char1 捕获组的值相同的字符。
\k&lt;char2&gt;	    匹配下一个与 char2 捕获组的值相同的字符。

3、已命名数值的反向引用

在具有 \k 的已命名反向引用中，name 也可以是 number 的字符串表示形式。 

如有以下句子
Today is a good dayay
模式：
(?&lt;1&gt;\w)(?&lt;2&gt;\w)\k&lt;1&gt;\k&lt;2&gt;
结果：
ayay

如果 name 是 number 的字符串表示形式，且没有捕获组具有该名称，\k&lt; name &gt; 与反向引用 \number 相同，其中 number 是捕获的序号位置。

如有以下句子
Today is a good dayay
模式：
(?&lt;char&gt;\w)\k&lt;1&gt;
结果：
oo
说明：
(?&lt;char&gt;\w)  匹配字词字符，并将结果分配到 char 捕获组。
\k&lt;1&gt;	     匹配下一个与 第一个捕获组的值相同的字符。因为没有捕获组叫1

如果 name 是 number 的字符串表示形式，并且已向该位置中的捕获组明确分配了数字名称，正则表达式分析器无法通过其序号位置识别捕获组。 
相反，它会引发参数异常。以下示例中的唯一捕获组名为“2”。 由于 \k 结构用于定义名为“1”的反向引用，因此正则表达式分析器无法识别第一个捕获组并引发异常。

模式：
(?&lt;2&gt;\w)\k&lt;1&gt;
结果：
参数异常

4、反向引用匹配什么内容
这个是文档的一部分，写一下。但感觉有点迷

如有以下句子
aababb

模式：
(?&lt;1&gt;a)(?&lt;1&gt;\1b)*

结果：
aababb

说明：
从该字符串的开头开始，成功将“a”与表达式 (?&lt;1&gt;a) 匹配。 此时，1 组的值为“a”。
继续匹配第二个字符，成功将字符串“ab”与表达式 \1b 或“ab”匹配。 然后，将结果“ab”分配到 \1。
继续匹配第四个字符。 表达式 (?&lt;1&gt;\1b)* 要匹配零次或多次，因此会成功将字符串“abb”与表达式 \1b 匹配。 然后，将结果“abb”分配回到 \1。
* 是循环限定符 -- 它将被重复计算，直到正则表达式引擎不能与它定义的模式匹配为止。 循环限定符不会清除组定义。

如有以下句子：
AA22ZZ
AABB

模式：
\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b

结果：
AA22ZZ
AABB

说明：
输入字符串可以匹配此正则表达式，即使第二个捕获组定义的两个十进制数字都不存在。 
即使匹配成功，也仍会在两个成功的捕获组之间找到空捕获组。


